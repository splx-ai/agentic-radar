<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SPLX Agentic Radar - Graph Visualization</title>
<script>
{% include 'assets/force-graph.js' %}
</script>
<script language="javascript" type="text/javascript">
const __INLINE_DATA = {{graph}};
</script>
<style>
body {
    margin: 0;
    padding: 0;
    font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background-color: white;
}

.header {
    background: linear-gradient(135deg, #2AF5D8 0%, #2A90F4 50%, #9281FF 100%);
    padding: 20px;
    text-align: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.header h1 {
    margin: 0;
    color: white;
    font-size: 20px;
    font-weight: 600;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
}

.header p {
    margin: 8px 0 0 0;
    color: rgba(255,255,255,0.9);
    font-size: 12px;
}

#graph {
    width: calc(100vw - 40px);
    height: calc(100vh - 140px);
    border: 0.5px solid #D4D4D4;
    background-color: white;
    margin: 20px;
    position: relative;
}

.controls {
    position: absolute;
    top: 100px;
    right: 40px;
    background: white;
    border: 0.5px solid #D4D4D4;
    border-radius: 4px;
    padding: 12px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    font-size: 10px;
    color: #777777;
    z-index: 1000;
}

.logo {
    width: 32px;
    height: 32px;
    fill: white;
}
</style>
</head>
<body>

<div class="header">
    <h1>
        <svg class="logo" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect width="40" height="40" rx="20" fill="white" fill-opacity="0.2"/>
            <path d="M11 20C11 21.1819 11.2328 22.3522 11.6851 23.4442C12.1374 24.5361 12.8003 25.5282 13.636 26.364C14.4718 27.1997 15.4639 27.8626 16.5558 28.3149C17.6478 28.7672 18.8181 29 20 29M11 20C11 18.8181 11.2328 17.6478 11.6851 16.5558C12.1374 15.4639 12.8003 14.4718 13.636 13.636C14.4718 12.8003 15.4639 12.1374 16.5558 11.6851C17.6478 11.2328 18.8181 11 20 11M11 20H15M20 29C21.1819 29 22.3522 28.7672 23.4442 28.3149C24.5361 27.8626 25.5282 27.1997 26.364 26.364C27.1997 25.5282 27.8626 24.5361 28.3149 23.4442C28.7672 22.3522 29 21.1819 29 20M20 29V26M29 20C29 18.8181 28.7672 17.6478 28.3149 16.5558C27.8626 15.4639 27.1997 14.4718 26.364 13.636C25.5282 12.8003 24.5361 12.1374 23.4442 11.6851C22.3522 11.2328 21.1819 11 20 11M29 20H26M20 11V15M20 20V20.01" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        SPLX Agentic Radar - Workflow Graph
    </h1>
    <p>{{project_name}} | {{framework}} | Generated {{timestamp}}</p>
</div>

<div class="controls">
    <div>üñ±Ô∏è Drag to pan</div>
    <div>üîç Scroll to zoom</div>
    <div>üëÜ Click nodes for details</div>
</div>

<div id="graph"></div>

<script>
// Initialize the force graph
const graph = ForceGraph()
    (document.getElementById('graph'))
    .graphData(__INLINE_DATA)
    .nodeAutoColorBy('type')
    .nodeCanvasObject((node, ctx, globalScale) => {
        const label = node.label || node.name || node.id;
        
        // Clean up label text - handle underscores and long names
        const cleanLabel = label
            .replace(/_/g, ' ')  // Replace underscores with spaces
            .replace(/([a-z])([A-Z])/g, '$1 $2')  // Add space before capitals
            .split(' ')
            .map(word => word.length > 15 ? word.substring(0, 12) + '...' : word)  // Truncate long words
            .join(' ');
        
        // Calculate text dimensions with wrapping
        const fontSize = Math.max(10/globalScale, 8);
        ctx.font = `${fontSize}px Inter, Sans-Serif`;
        
        // Multi-line text wrapping
        const maxWidth = 140/globalScale;
        const words = cleanLabel.split(' ');
        const lines = [];
        let currentLine = words[0] || '';
        
        for (let i = 1; i < words.length; i++) {
            const testLine = currentLine + ' ' + words[i];
            const testWidth = ctx.measureText(testLine).width;
            if (testWidth > maxWidth && currentLine.length > 0) {
                lines.push(currentLine);
                currentLine = words[i];
            } else {
                currentLine = testLine;
            }
        }
        if (currentLine) lines.push(currentLine);
        
        // Calculate background dimensions
        const lineHeight = fontSize * 1.3;
        const textHeight = lines.length * lineHeight;
        const textWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
        const padding = fontSize * 0.4;
        const bckgWidth = Math.max(textWidth + padding * 2, 60/globalScale);
        const bckgHeight = textHeight + padding * 2;
        
        // Draw node background with rounded corners
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.strokeStyle = node.color || '#999';
        ctx.lineWidth = 1.5/globalScale;
        
        // Rounded rectangle
        const radius = 4/globalScale;
        const x = node.x - bckgWidth/2;
        const y = node.y - bckgHeight/2;
        
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + bckgWidth, y, x + bckgWidth, y + bckgHeight, radius);
        ctx.arcTo(x + bckgWidth, y + bckgHeight, x, y + bckgHeight, radius);
        ctx.arcTo(x, y + bckgHeight, x, y, radius);
        ctx.arcTo(x, y, x + bckgWidth, y, radius);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Draw icon if available (smaller, positioned top-left)
        if (node.image) {
            if (!node._img) {
                node._img = new Image();
                node._img.src = node.image;
            }
            
            if (node._img.complete) {
                const iconSize = Math.min(16/globalScale, bckgWidth * 0.25);
                ctx.drawImage(
                    node._img, 
                    x + padding, 
                    y + padding,
                    iconSize, 
                    iconSize
                );
            }
        }
        
        // Draw multi-line text centered
        ctx.fillStyle = '#333';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const startY = node.y - (lines.length - 1) * lineHeight / 2;
        lines.forEach((line, index) => {
            ctx.fillText(line, node.x, startY + index * lineHeight);
        });
        
        // Store node dimensions for better collision detection
        node._width = bckgWidth;
        node._height = bckgHeight;
    })
    .linkDirectionalArrowLength(6)
    .linkDirectionalArrowRelPos(1)
    .linkCurvature(0.25)
    .linkWidth(2)
    
    // Improved force simulation for better layout
    .d3Force('charge', d3.forceManyBody().strength(-400))
    .d3Force('link', d3.forceLink().distance(120).strength(0.6))
    .d3Force('center', d3.forceCenter())
    .d3Force('collision', d3.forceCollide().radius(node => {
        return Math.max((node._width || 80) / 2, (node._height || 40) / 2) + 15;
    }))
    
    // Enhanced zoom with boundaries
    .enableZoomInteraction(true)
    .onZoom(({ k, x, y }) => {
        // Limit zoom level to prevent issues
        const minZoom = 0.1;
        const maxZoom = 4;
        if (k < minZoom || k > maxZoom) return false;
    });

// Enhanced node click handler with better text formatting
graph.onNodeClick(node => {
    const displayName = (node.name || node.id || 'Unknown')
        .replace(/_/g, ' ')
        .replace(/([a-z])([A-Z])/g, '$1 $2');
        
    const info = [];
    info.push(`Node: ${displayName}`);
    info.push(`Type: ${node.type || node.node_class || 'agent'}`);
    if (node.description) info.push(`Description: ${node.description}`);
    if (node.role) info.push(`Role: ${node.role}`);
    if (node.tools && node.tools.length > 0) {
        info.push(`Tools: ${node.tools.length}`);
    }
    
    // Create better modal instead of alert
    showNodeDetails(info.join('\n'));
});

// Enhanced node details display
function showNodeDetails(details) {
    // Remove existing modal if any
    const existingModal = document.querySelector('.node-modal');
    if (existingModal) existingModal.remove();
    
    const modal = document.createElement('div');
    modal.className = 'node-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        backdrop-filter: blur(2px);
    `;
    
    const content = document.createElement('div');
    content.style.cssText = `
        background: white;
        padding: 24px;
        border-radius: 12px;
        max-width: 400px;
        max-height: 60vh;
        overflow-y: auto;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        border: 1px solid #E5E7EB;
    `;
    
    content.innerHTML = `
        <h3 style="margin: 0 0 16px 0; color: #1F2937; font-size: 18px; font-weight: 600;">
            Node Details
        </h3>
        <div style="white-space: pre-wrap; font-family: inherit; margin: 0; color: #374151; line-height: 1.5;">
            ${details}
        </div>
        <button onclick="this.closest('.node-modal').remove()" 
                style="margin-top: 20px; padding: 10px 20px; background: linear-gradient(135deg, #2AF5D8 0%, #2A90F4 50%, #9281FF 100%); 
                       color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;
                       transition: transform 0.1s ease;">
            Close
        </button>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
    
    // Close on background click or escape key
    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
    });
    
    document.addEventListener('keydown', function escHandler(e) {
        if (e.key === 'Escape') {
            modal.remove();
            document.removeEventListener('keydown', escHandler);
        }
    });
}

// Auto-fit graph with better timing and padding to keep edges in bounds
setTimeout(() => {
    graph.zoomToFit(2000, 80); // Longer duration, more padding
}, 500);
</script>

</body>
</html>